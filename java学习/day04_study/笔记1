- static关键字
    - 静态关键
    - 可以修饰方法 成员变量
    - 类级别的关键字
    - 优先于对象的存在
    - 被static修饰的成员变量，静态代码块会随着类的加载而加载
    - 被static修饰的方法成为静态方法静态方法的内存是划分在栈中，方法压栈 java所有的方法都是存放在栈中的
    - 静态变量的jvm上的存储区域是在方法区的静态区，会随着类的加载而加载，并且只加载一次
    - 常量(程序运行期间，值不能随意发生改变的量)
        - final关键字
            - 最终的，不可改变的
            - 可以修饰方法，可以修饰类，可以修饰属性
            - 被final修饰的类是不可以被继承的
            - 被final修饰的方法是不可以被重写的
            - 被final修饰的变量
                - 基本数据类型 值不可以随意发生改变
                - 引用数据类型 不能指向别的内存空间
        - 如何定义变量
            - 通过static和final结合去修饰一个变量，那么该变量性质就会发生改变，会变成一个常量
                - 通过static修饰是为了内存在方法区中开辟，只开辟一份，节约内存
                - 通过final修饰是为了值不能发生变化
                - 常量的名词是全大写的
- 继承
    - 子类不可以继承父类的构造方法
    - 在java中，两个类可以通过extends关键字来体现继承关系
    - 当子类需要使用到父类资源 时，可以使用继承去体现，这样就无需再重新定义资源了，直接子类继承父类资源即可
    - A extends B{} A就是子类，B就是父类
        - 子类继承父类之后，可以获取父类所有的资源(私有资源是访问不到的，但是也是被继承了的
    - 继承要满足is a的关系
    - 在java中是不可以多继承的，但是可以多层继承
        - 一个子类不能继承多个父类
        - 但是当子类继承了父类，这个父类可以继承别的父类
        - A extends B 之后A就不能继承其他类了，但是B可以继承其他父类
    - 重写/覆盖 必须建立在继承的关系下
        - 当子类和父类拥有了同名方法就构成了重写
        - 在什么情况下不需要重写
            - 当父类方法的功能不能够满足子类需求时，就需要用到重写
    - 继承的好处
        -提高了代码的重用性和维护性
    - this和supper的使用
        - this表示当前类的实例的引用
        - supper表示父类的引用 supper()调用父类的无参构造 默认存在
        - 用法:
            - this.本类实例变量 supper.父类实例变量
            - supper() 指向父类的无参构造 子类实例在创建之前 会先创建父类实例,只能写在子类的构造中
            - this() 指向类的构造
            - supper() 和 this() 是不能共存的 因为代码只能出现在构造的第一行
            - 调用实例方法: this.本类 实例方法 supper.父类 实例方法
方法压栈

